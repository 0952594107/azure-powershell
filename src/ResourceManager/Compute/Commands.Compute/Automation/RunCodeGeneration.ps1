[CmdletBinding()]
param(
  [Parameter(Mandatory = $true)]
  [string]$dllFolder,

  [Parameter(Mandatory = $true)]
  [string]$outFolder,

  # Cmdlet Code Generation Style
  # 1. Invoke (default) that uses Invoke as the verb, and Operation + Method (e.g. VirtualMachine + Get)
  # 2. Verb style that maps the method name to a certain common PS verb (e.g. CreateOrUpdate -> New)
  [Parameter(Mandatory = $false)]
  [string]$cmdletStyle = 'Invoke'
)

$code_common_header =
@"
// 
// Copyright (c) Microsoft and contributors.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// 
// See the License for the specific language governing permissions and
// limitations under the License.
// 

// Warning: This code was generated by a tool.
// 
// Changes to this file may cause incorrect behavior and will be lost if the
// code is regenerated.
"@;

$client_library_namespace = 'Microsoft.Azure.Management.Compute';
$code_common_namespace = ($client_library_namespace.Replace('.Management.', '.Commands.')) + '.Automation';

function Get-NormalizedName
{
    param(
        [Parameter(Mandatory = $True)]
        [string]$inputName
    )

    if ([string]::IsNullOrEmpty($inputName))
    {
        return $inputName;
    }

    if ($inputName.StartsWith('vm'))
    {
        $outputName = 'VM' + $inputName.Substring(2);
    }
    else
    {
        [char]$firstChar = $inputName[0];
        $firstChar = [System.Char]::ToUpper($firstChar);
        $outputName = $firstChar + $inputName.Substring(1);
    }

    return $outputName;
}

function Get-OperationShortName
{
    param(
        [Parameter(Mandatory = $True)]
        [string]$opFullName
    )

    $prefix = 'I';
    $suffix = 'Operations';
    $opShortName = $opFullName;

    if ($opFullName.StartsWith($prefix) -and $opShortName.EndsWith($suffix))
    {
        $opShortName = $opShortName.Substring($prefix.Length, ($opShortName.Length - $prefix.Length - $suffix.Length));
    }

    return $opShortName;
}

function Write-BaseCmdletFile
{
    param(
        [Parameter(Mandatory = $True)]
        [string]$fileFullPath,

        [Parameter(Mandatory = $True)]
        $operationNameList,

        [Parameter(Mandatory = $True)]
        $clientClass
    )


    [System.Reflection.PropertyInfo[]]$propItems = $clientClass.GetProperties();

    $operation_get_code = "";
    foreach ($opFullName in $operationNameList)
    {
        [string]$sOpFullName = $opFullName;
        Write-Output ('$sOpFullName = ' + $sOpFullName);
        $prefix = 'I';
        $suffix = 'Operations';
        if ($sOpFullName.StartsWith($prefix) -and $sOpFullName.EndsWith($suffix))
        {
            $opShortName = Get-OperationShortName $sOpFullName;
            $opPropName = $opShortName;
            foreach ($propItem in $propItems)
            {
                if ($propItem.PropertyType.Name -eq $opFullName)
                {
                    $opPropName = $propItem.Name;
                    break;
                }
            }

            $operation_get_template = 
@"
        public I${opShortName}Operations ${opShortName}Client
        {
            get
            {
                return ComputeClient.ComputeManagementClient.${opPropName};
            }
        }
"@;

            if (-not ($operation_get_code -eq ''))
            {
                $operation_get_code += "`r`n";
            }

            $operation_get_code += $operation_get_template;
        }
    }

    $source_template =
@"
${code_common_header}

using ${client_library_namespace};

namespace ${code_common_namespace}
{
    public abstract class ComputeAutomationBaseCmdlet : ComputeClientBaseCmdlet
    {
${operation_get_code}
    }
}
"@;

    Set-Content -Path $fileFullPath -Value ($source_template | Out-String) -Force;
}

function Write-OperationCmdletFile
{
    param(
        [Parameter(Mandatory = $True)]
        [string]$fileOutputFolder,

        [Parameter(Mandatory = $True)]
        $opShortName,

        [Parameter(Mandatory = $True)]
        [System.Reflection.MethodInfo]$operationMethodInfo
    )

    $methodName = ($operationMethodInfo.Name.Replace('Async', ''));
    $cmdlet_verb = "Invoke";
    $cmdlet_noun = "Azure" + $opShortName + $methodName;
    $cmdlet_class_name = $cmdlet_verb + $cmdlet_noun + 'Cmdlet';

    $indents = " " * 8;
    $new_line = "`r`n";
    $get_set_block = '{ get; set; }';
    
    $cmdlet_generated_code = '';
    # $cmdlet_generated_code += $indents + '// ' + $operationMethodInfo + $new_line;

    $params = $operationMethodInfo.GetParameters();
    [System.Collections.ArrayList]$param_names = @();
    foreach ($pt in $params)
    {
        $paramTypeFullName = $pt.ParameterType.FullName;
        if (-not ($paramTypeFullName.EndsWith('CancellationToken')))
        {
            $normalized_param_name = Get-NormalizedName $pt.Name;

            Write-Output ('    ' + $paramTypeFullName + ' ' + $normalized_param_name);

            $param_attributes = $indents + "[Parameter(Mandatory = true), ValidateNotNullOrEmpty]" + $new_line;
            $param_definition = $indents + "public ${paramTypeFullName} ${normalized_param_name} " + $get_set_block + $new_line;
            $param_code_content = $param_attributes + $param_definition;

            $cmdlet_generated_code += $param_code_content + $new_line;

            $param_names.Add($normalized_param_name);
        }
    }

    $params_join_str = [string]::Join(', ', $param_names.ToArray());

    $cmdlet_client_call_template =
@"
        public override void ExecuteCmdlet()
        {
            base.ExecuteCmdlet();

            ExecuteClientAction(() =>
            {
                var result = ${opShortName}Client.${methodName}(${params_join_str});
                WriteObject(result, true);
            });
        }
"@;

    $cmdlet_generated_code += $cmdlet_client_call_template;

    $cmdlt_source_template =
@"
${code_common_header}

using Microsoft.Azure.Management.Compute;
using System.Management.Automation;

namespace Microsoft.Azure.Commands.Compute.Automation
{
    [Cmdlet(`"${cmdlet_verb}`", `"${cmdlet_noun}`")]
    public class ${cmdlet_class_name} : ComputeAutomationBaseCmdlet
    {
${cmdlet_generated_code}
    }
}
"@;

    $fileFullPath = $fileOutputFolder + '/' + $cmdlet_class_name + '.cs';
    Set-Content -Path $fileFullPath -Value $cmdlt_source_template -Force;
}

Write-Output $dllFolder;
Write-Output $outFolder;

$outFolder += '/Generated';

$output = Get-ChildItem -Path $dllFolder | Out-String;

# Set-Content -Path ($outFolder + '/Output.txt');
Write-Output $output;


$dllname = 'Microsoft.Azure.Management.Compute';
$dllfile = $dllname + '.dll';
$dllFileFullPath = $dllFolder + '\' + $dllfile;

if (-not (Test-Path -Path $dllFileFullPath))
{
    Write-Output "DLL file `'$dllFileFullPath`' not found. Exit.";
}
else
{
    $assembly = [System.Reflection.Assembly]::LoadFrom($dllFileFullPath);
    
    # All original types
    $types = $assembly.GetTypes();
    $filtered_types = $types | where { $_.Namespace -eq $dllname -and $_.Name -like 'I*Operations' };
    Write-Output ($filtered_types | select Namespace, Name);

    # Write Base Cmdlet File
    $baseCmdletFileFullName = $outFolder + '\' + 'ComputeAutomationBaseCmdlet.cs';
    $opNameList = ($filtered_types | select -ExpandProperty Name);
    $clientClassType = $types | where { $_.Namespace -eq $dllname -and $_.Name -eq 'IComputeManagementClient' };
    Write-BaseCmdletFile $baseCmdletFileFullName $opNameList $clientClassType;

    # Write Cmdlet Files
    foreach ($ft in $filtered_types)
    {
        Write-Output '=============================================';
        Write-Output $ft.Name;
        Write-Output '=============================================';
    
        $opShortName = Get-OperationShortName $ft.Name;
        $opOutFolder = $outFolder + '/' + $opShortName;
        $st = rmdir -Recurse -Force $opOutFolder;
        $st = mkdir -Force $opOutFolder;

        $methods = $ft.GetMethods();
        foreach ($mt in $methods)
        {
            Write-Output ($mt.Name.Replace('Async', ''));
            Write-OperationCmdletFile $opOutFolder $opShortName $mt;
        }
    }

    Write-Output "=============================================";
    Write-Output "Finished.";
    Write-Output "=============================================";
}
