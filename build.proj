<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  
  <!--
  Available Targets:

  /t:Clean
    Removes temporary build outputs.
    
  /t:Build
    Builds assemblies.

  /t:Test
    Runs tests

  /p:CodeSign=True
    Code sign binaries, mainly for official release. Default is false.

  /p:CodeSign=True;DelaySign=True
    Test the code sign workflow locally. 
  
  -->  

  <!-- Define build properties -->
  <PropertyGroup>
    <LibraryRoot>$(MSBuildThisFileDirectory)</LibraryRoot>
    <LibrarySourceFolder>$(LibraryRoot)src</LibrarySourceFolder>
    <LibraryToolsFolder>$(LibraryRoot)tools</LibraryToolsFolder>
    <PublishDirectory>$(LibrarySourceFolder)\Publish</PublishDirectory>
    <PackageDirectory>$(LibrarySourceFolder)\Package</PackageDirectory>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <CodeSign Condition=" '$(CodeSign)' == '' ">false</CodeSign>
    <!--Set this true only if you want to test the code sign workflow locally-->
    <DelaySign Condition =" '$(DelaySign)' == '' ">false</DelaySign>
    <BuildOutputDirectory>$(PublishDirectory)\Build</BuildOutputDirectory>
    <SetupOutputDirectory>$(PublishDirectory)\Setup</SetupOutputDirectory>
    <TestOutputDirectory>$(PublishDirectory)\TestResults</TestOutputDirectory>
    <BuildInParallel Condition="'$(BuildInParallel)' == ''">true</BuildInParallel>
  </PropertyGroup>
  <ItemGroup>
    <AzureResourceManagerSln Include=".\src\ResourceManager.sln" />
    <AzureServiceManagementSln Include=".\src\ServiceManagement.sln" />
    <SetupSln Include=".\setup\azurepowershell.sln" />
    <SetupPowershellGetSln Include=".\setup-powershellget\powershellget.sln" />
  </ItemGroup>
  
  <!--
  CI build related
  -->
  <PropertyGroup>
    <!--OnPremiseBuildTasks is not a good name, but CI server is using that, will update across soon-->
    <CIToolsPath>$(OnPremiseBuildTasks)</CIToolsPath>
    <OnPremiseBuild Condition=" Exists($(OnPremiseBuildTasks)) ">true</OnPremiseBuild>
    <OnPremiseBuild Condition=" ! Exists($(OnPremiseBuildTasks)) ">false</OnPremiseBuild>
  </PropertyGroup>
  <UsingTask Condition=" $(OnPremiseBuild) " TaskName="CodeSigningTask" AssemblyFile="$(CIToolsPath)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
  <UsingTask Condition=" $(OnPremiseBuild) " TaskName="CorporateValidation" AssemblyFile="$(CIToolsPath)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
  <Import Condition=" $(OnPremiseBuild) " Project="$(CIToolsPath)\Microsoft.WindowsAzure.Build.OnPremise.msbuild" />

  <UsingTask 
    AssemblyFile="$(MSBuildProjectDirectory)\src\packages\xunit.MSBuild.2.0.0.0\tools\xunit.runner.msbuild.dll"
    TaskName="Xunit.Runner.MSBuild.xunit" />
  
  <!-- Clean the build in all configurations -->
  <Target Name="Clean">
    <!-- Clean the solutions -->
    <Message Importance="high" Text="Cleaning Cmdlets..." ContinueOnError="false" />
    <MSBuild
      Projects="@(AzureResourceManagerSln)"
      Targets="Clean"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      ContinueOnError="false" />
    <MSBuild
      Projects="@(AzureServiceManagementSln)"
      Targets="Clean"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      ContinueOnError="false" />
    <MSBuild
      Projects="@(SetupSln)"
      Targets="Clean"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      ContinueOnError="false" />
    <MSBuild
      Projects="@(SetupPowershellGetSln)"
      Targets="Clean"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      ContinueOnError="false" />
      
    <!-- Delete the publish files -->
    <Message Importance="high" Text="Cleaning publish files..." ContinueOnError="false" />
    <ItemGroup>
      <PublishFiles Include="$(PublishDirectory)\**\*.*" />
    </ItemGroup>
    <Delete
      Files="@(PublishFiles)"
      ContinueOnError="false" />
    <RemoveDir
      Directories="$(PublishDirectory)"
      ContinueOnError="false" />

    <!-- Delete the package files -->
    <Message Importance="high" Text="Cleaning package files..." ContinueOnError="false" />
    <ItemGroup>
      <PackageFiles Include="$(PackageDirectory)\**\*.*" />
    </ItemGroup>
    <Delete
      Files="@(PackageFiles)"
      ContinueOnError="false" />
    <RemoveDir
      Directories="$(PackageDirectory)"
      ContinueOnError="false" />
  </Target>
  
  <PropertyGroup>
    <NuGetCommand>$(MSBuildProjectDirectory)\src\.nuget\NuGet.exe</NuGetCommand>
    <NuGetRestoreConfigFile>$(MSBuildProjectDirectory)\restore.config</NuGetRestoreConfigFile>
    <NuGetRestoreConfigSwitch>-ConfigFile &quot;$(NuGetRestoreConfigFile)&quot;</NuGetRestoreConfigSwitch>
  </PropertyGroup>
  
  <!--
  Force nuget package restore so that packages that include .targets files
  don't need to be checked into source control.
  -->
  <Target Name="RestoreNugetPackages">
    <!-- Delete NuGet cache-->
    <!--<ItemGroup>
      <NuGetCache Include="$(LOCALAPPDATA)\NuGet\Cache\*.nupkg"/>
    </ItemGroup>
    <Delete Files="@(NuGetCache)" />-->
    
    <Delete Files="$(NuGetRestoreConfigFile)" />
    <WriteLinesToFile
      File="$(NuGetRestoreConfigFile)"
      Lines="&lt;configuration&gt;&lt;/configuration&gt;"
      Overwrite="true"
      Encoding="Unicode"/>

    <Exec Command="$(NuGetCommand) sources add -Name LocalFeed -Source &quot;$(MSBuildProjectDirectory)\tools\LocalFeed&quot; $(NuGetRestoreConfigSwitch)"/>

    <!-- Restore packages -->
    <Exec Command="$(NuGetCommand) restore $(MSBuildProjectDirectory)\src\ResourceManager.sln $(NuGetRestoreConfigSwitch)" ContinueOnError="false" />
    <Exec Command="$(NuGetCommand) restore $(MSBuildProjectDirectory)\src\ServiceManagement.sln $(NuGetRestoreConfigSwitch)" ContinueOnError="false" />
    
    <!--Restore the xunit runner needed to run unit tests-->
    <Exec Command="$(NuGetCommand) restore $(MSBuildProjectDirectory)\packages.config -PackagesDirectory $(MSBuildProjectDirectory)\packages" />
    
    <Delete Files="$(NuGetRestoreConfigFile)" />
  </Target>

  <!-- Build all flavors of the Cmdlets -->
  <Target Name="Build" DependsOnTargets="RestoreNugetPackages;BuildMsBuildTask">
    <Message Importance="high" Text="Building Cmdlets..." />
    <MSBuild
      Projects="@(AzureResourceManagerSln)"
      Targets="Build"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      BuildInParallel="$(BuildInParallel)" ContinueOnError="false" />
    <MSBuild
      Projects="@(AzureServiceManagementSln)"
      Targets="Build"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      BuildInParallel="$(BuildInParallel)" ContinueOnError="false" />
      
    <CallTarget Targets="CodeSignBinaries" Condition=" '$(CodeSign)' == 'true' " />
    
    <Message Importance="high" Text="Building Setup..." />
    <MSBuild
      Projects="@(SetupPowershellGetSln)"
      Targets="Build"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      ContinueOnError="false" />
    <MSBuild
      Projects="@(SetupSln)"
      Targets="Build"
      Properties="Configuration=$(Configuration);Platform=Any CPU"
      ContinueOnError="false" />
    
    <CallTarget Targets="CodeSignInstaller" Condition=" '$(CodeSign)' == 'true' " />    
  </Target>
  
  <Target Name="CodeSignBinaries">
    <Error Condition=" !$(OnPremiseBuild) and !$(DelaySign) " Text="No CI tools path available, the code sign will be unable to continue. $(CIToolsPath)" />

    <Message Text="Code signing" Importance="high" />

    <Message Text="Signing project: $(MSBuildProjectFullPath)" />
    
    <MSBuild Projects="$(MSBuildProjectFullPath)"
             Targets="SignBinaries"
             Properties="StrongNameToken=$(StrongNameToken)">    
    </MSBuild>
    
    <CallTarget Targets="ValidateCorporateCompliance" Condition="!$(DelaySign)"/>
  </Target>
  
  <Target Name="CodeSignInstaller">
    <Error Condition=" !$(OnPremiseBuild) and !$(DelaySign) " Text="No CI tools path available, the code sign will be unable to continue. $(CIToolsPath)" />

    <Message Text="Code signing installer" Importance="high" />

    <Message Text="Signing project: $(MSBuildProjectFullPath)" />
    
    <MSBuild Projects="$(MSBuildProjectFullPath)"
             Targets="SignInstaller"
             Properties="StrongNameToken=$(StrongNameToken)">    
    </MSBuild>
    
    <CallTarget Targets="ValidateCorporateCompliance" Condition="!$(DelaySign)"/>
  </Target>

  <!-- Do everything possible -->
  <Target
    Name="Full"
    DependsOnTargets="Clean;Build;Test" />
    
  <Target Name="BuildMsBuildTask" DependsOnTargets="RestoreNugetPackages">
    <MSBuild Projects="$(LibraryToolsFolder)\BuildPackagesTask\Microsoft.Azure.Build.Tasks.csproj"
             Targets="Build" Properties="Configuration=Debug;Platform=AnyCPU" />
  </Target>
  
  <UsingTask TaskName="ValidateStrongNameSignatureTask" AssemblyFile="$(LibraryToolsFolder)\Microsoft.Azure.Build.Tasks.dll"  />
  <UsingTask TaskName="FilterOutAutoRestLibraries" AssemblyFile="$(LibraryToolsFolder)\Microsoft.Azure.Build.Tasks.dll"  />  
  
  <Target Name="SignBinaries">
    <PropertyGroup>
      <!--public token associated with MSSharedLibKey.snk-->
      <StrongNameToken Condition=" '$(StrongNameToken)' == '' ">31bf3856ad364e35</StrongNameToken>
    </PropertyGroup>
    <GetFrameworkSdkPath>
      <Output TaskParameter="Path" PropertyName="WindowsSdkPath"/>
    </GetFrameworkSdkPath>

    <ItemGroup>
      <DelaySignedAssembliesToValidate Include="src\Package\$(Configuration)\**\Microsoft*Azure*Commands*.dll" />
      <DelaySignedAssembliesToValidate Include="src\Package\$(Configuration)\**\Microsoft.Azure.Common.Extensions.dll" />
      <DelaySignedFilesToValidate Include="@(DelaySignedAssembliesToValidate)" />
      <DelaySignedFilesToValidate Include="src\Package\$(Configuration)\**\*.ps1" />
      <DelaySignedFilesToValidate Include="setup*\build\$(Configuration)\AzurePowerShell*.msi" />
    </ItemGroup>
    
    <Message Importance="high" Text="src\Package\$(Configuration) does not contains any files to sign. Code sign will skip." 
             Condition="'@(DelaySignedFilesToValidate)' == ''" />
             
    <ValidateStrongNameSignatureTask
      WindowsSdkPath="$(WindowsSdkPath)"
      Assembly="%(DelaySignedAssembliesToValidate.Identity)"
      ExpectedTokenSignature="$(StrongNameToken)"
      ExpectedDelaySigned="true"
      ContinueOnError="false" 
      Condition="'@(DelaySignedAssembliesToValidate)' != ''"/>

    <CodeSigningTask
      Description="Microsoft Azure PowerShell"
      Keywords="Microsoft Azure PowerShell"
      UnsignedFiles="@(DelaySignedFilesToValidate)"
      DestinationPath="signed"
      SigningLogPath="signed\signing.log"
      ToolsPath="$(CIToolsPath)"
      Condition="!$(DelaySign) and '@(DelaySignedFilesToValidate)' != ''"/>  
      
    <!--If we are testing locally then we copy the binaries and do not submit to the code sign server-->
    <Copy SourceFiles="@(DelaySignedFilesToValidate)" DestinationFolder="signed" Condition="$(DelaySign)" />
    
    <ItemGroup>
      <AfterSignedAssembliesToValidate Include="signed\*.dll" />
    </ItemGroup>
    <ValidateStrongNameSignatureTask
        WindowsSdkPath="$(WindowsSdkPath)"
        Assembly="%(AfterSignedAssembliesToValidate.Identity)"
        ExpectedTokenSignature="$(StrongNameToken)"
        ExpectedDelaySigned="false"
        ContinueOnError="false" 
        Condition="!$(DelaySign) and '@(AfterSignedAssembliesToValidate)' != ''"/>
    
    <Message Text="TODO: Copy signed files back"/>
  </Target>
  
  <Target Name="SignInstaller">
    <PropertyGroup>
      <!--public token associated with MSSharedLibKey.snk-->
      <StrongNameToken Condition=" '$(StrongNameToken)' == '' ">31bf3856ad364e35</StrongNameToken>
    </PropertyGroup>
    <GetFrameworkSdkPath>
      <Output TaskParameter="Path" PropertyName="WindowsSdkPath"/>
    </GetFrameworkSdkPath>

    <ItemGroup>
      <DelaySignedFilesToValidate Include="setup*\build\$(Configuration)\AzurePowerShell*.msi" />
    </ItemGroup>
    
    <Message Importance="high" Text="setup*\build\$(Configuration) does not contains any installer files to sign. Code sign will skip." 
             Condition="'@(DelaySignedFilesToValidate)' == ''" />
    
    <CodeSigningTask
      Description="Microsoft Azure PowerShell"
      Keywords="Microsoft Azure PowerShell"
      UnsignedFiles="@(DelaySignedFilesToValidate)"
      DestinationPath="signed"
      SigningLogPath="signed\signing.log"
      ToolsPath="$(CIToolsPath)"
      Condition="!$(DelaySign) and '@(DelaySignedFilesToValidate)' != ''"/>  
      
    <!--If we are testing locally then we copy the binaries and do not submit to the code sign server-->
    <Copy SourceFiles="@(DelaySignedFilesToValidate)" DestinationFolder="signed" Condition="$(DelaySign)" />
    
    <Message Text="TODO: Copy signed files back"/>
  </Target>

  <PropertyGroup>
    <RunTestLive Condition="'$(RunTestLive)' == ''">false</RunTestLive>
    <XUnitIncludedTrait Condition="!$(RunTestLive)">AcceptanceType=CheckIn</XUnitIncludedTrait>
  </PropertyGroup>
  
  <!-- Note: all testing related target should go to 'AzurePowershell.test.targets' file except the one used by CI run -->
  <Import Project="$(MSBuildThisFileDirectory)AzurePowershell.test.targets"/>
  
  <!-- Run checkin tests for each pull request -->
  <Target Name="Test" DependsOnTargets="Build;BeforeRunTests">
    <Message Importance="high" Text="Running check in tests..." />
    <CallTarget Targets="InvokeXUnit"/>
  </Target>
  
  <!-- Run Full switch with scenario tests -->
  <Target
    Name="FullWithScenarioTests"
    DependsOnTargets="Clean;Build;Test;RunOneSDKCIT" />
  
  <!-- Run live tests and record mocks -->
    <Target
    Name="RunLiveTests"
    DependsOnTargets="Clean;Build;LiveTestsFilter" />

    <Target Name="LiveTestsFilter" DependsOnTargets="Build;BeforeRunTests">
    <Message Importance="high" Text="Running live tests..." />
    <CallTarget Targets="LiveTests"/>
  </Target>
</Project>
